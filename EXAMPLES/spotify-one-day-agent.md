# Example: Spotify One-Day Agent

**Scenario:** Create an agent that plays Spotify songs for one day, then self-destructs.

The agent can be:
- **Python script** (runs on server)
- **iOS app** (runs on iPhone)
- **Android app** (runs on phone)

All using the same QUAD protocol!

---

## Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1: User Asks Agent to Create Spotify Agent                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User (Voice/Text)
    â†“
    "Create an agent that plays my morning playlist
     on Spotify for the next 24 hours, then stop"
    â†“
SUMA (Main Agent)
    â†“
    Analyzes request:
    - Task: Play Spotify songs
    - Duration: 24 hours
    - Action after: Self-destruct
    â†“
    Calls: generate_agent()
    â†“
    Creates: spotify_player_agent.py (or .swift or .kt)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Generated Agent Runs                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Spotify Agent (Generated)
    â”œâ”€ Configuration:
    â”‚   â”œâ”€ playlist_id: "morning_vibes"
    â”‚   â”œâ”€ duration_hours: 24
    â”‚   â”œâ”€ auto_destroy: true
    â”‚   â””â”€ notify_url: "https://asksuma.ai/api/agent/destroyed"
    â”‚
    â”œâ”€ Trigger:
    â”‚   â”œâ”€ Type: Time-based loop
    â”‚   â””â”€ Interval: Play songs continuously
    â”‚
    â”œâ”€ Self-Destruct Timer:
    â”‚   â””â”€ After: 24 hours
    â”‚
    â””â”€ Capabilities:
        â”œâ”€ self_heal (if Spotify API changes)
        â”œâ”€ talk_to_agent (can notify user)
        â””â”€ self_destroy (after 24 hours)


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: Agent Self-Destructs                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After 24 hours:
    â†“
Agent checks timer
    â†“
Timer expired â†’ Trigger self_destroy()
    â†“
Agent sends notification:
    POST https://asksuma.ai/api/agent/destroyed
    {
      "agent_id": "spotify-player-001",
      "reason": "24 hour timer expired",
      "songs_played": 127,
      "runtime_hours": 24
    }
    â†“
Agent cleans up:
    - Stops Spotify playback
    - Saves final state
    - Deletes temporary files
    â†“
Agent terminates process
    â†“
Gone! ğŸ’€
```

---

## Implementation in Different Languages

### Option 1: Python Agent (Server-Side)

**Request to SUMA:**
```bash
curl -X POST https://asksuma.ai/api/agent/generate \
  -H "Content-Type: application/json" \
  -d '{
    "creator_agent_id": "user-suma-001",
    "agent_type": "spotify_player",
    "task_description": "Play morning playlist on Spotify for 24 hours",
    "restrictions": {
      "playlist_id": "37i9dQZF1DX0XUsuxWHRQd",
      "duration_hours": 24,
      "allowed_actions": ["play", "pause", "next"],
      "auto_destroy_after_hours": 24
    },
    "language": "python",
    "include_self_healing": true
  }'
```

**SUMA Generates:**

```python
# spotify_player_agent.py
# Auto-generated by SUMA on 2026-01-11
# Duration: 24 hours, then self-destruct

from quad_agent import QUADAgent
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import time
from datetime import datetime, timedelta

class SpotifyPlayerAgent(QUADAgent):
    """
    Plays Spotify playlist for 24 hours, then self-destructs
    """

    def __init__(self):
        super().__init__(
            agent_id="spotify-player-001",
            agent_type="spotify_player",
            suma_api_url="https://asksuma.ai/api",
            trigger={
                "type": "time",
                "schedule": "continuous",  # Keep running
                "check_interval_seconds": 60
            }
        )

        # Self-destruct timer
        self.created_at = datetime.now()
        self.destroy_at = self.created_at + timedelta(hours=24)

        # Spotify client
        self.spotify = spotipy.Spotify(auth_manager=SpotifyOAuth(
            client_id=self.config["spotify_client_id"],
            client_secret=self.config["spotify_client_secret"],
            redirect_uri="http://localhost:8080",
            scope="user-read-playback-state,user-modify-playback-state"
        ))

        self.songs_played = 0
        self.playlist_id = self.config.get("playlist_id")

    # PRETEXT: This function plays Spotify songs
    # You can ONLY modify:
    # 1. Spotify API calls if API changes
    # 2. Playback logic
    # You CANNOT:
    # 1. Change self-destruct timer
    # 2. Skip songs without user permission
    # 3. Change playlist without user permission
    def execute_task(self):
        """
        Play songs from Spotify playlist
        """
        # Check if it's time to self-destruct
        if datetime.now() >= self.destroy_at:
            print(f"[{self.agent_id}] 24 hours elapsed - initiating self-destruct")
            self.self_destroy("24 hour timer expired")
            return {"destroyed": True}

        try:
            # Get current playback
            current_playback = self.spotify.current_playback()

            if not current_playback or not current_playback['is_playing']:
                # Start playing playlist
                print(f"[{self.agent_id}] Starting playlist: {self.playlist_id}")
                self.spotify.start_playback(
                    context_uri=f"spotify:playlist:{self.playlist_id}"
                )
                self.songs_played += 1
            else:
                # Continue playing
                track = current_playback['item']['name']
                artist = current_playback['item']['artists'][0]['name']
                print(f"[{self.agent_id}] Now playing: {track} by {artist}")

            # Calculate remaining time
            remaining = self.destroy_at - datetime.now()
            remaining_hours = remaining.total_seconds() / 3600

            return {
                "status": "playing",
                "songs_played": self.songs_played,
                "remaining_hours": round(remaining_hours, 2),
                "will_destroy_at": self.destroy_at.isoformat()
            }

        except Exception as e:
            # If Spotify API fails, try to self-heal
            print(f"[{self.agent_id}] Error: {e}")
            return self.self_heal(e)

    # END_PRETEXT

    def _get_pretext(self):
        return """
        This agent plays Spotify songs for 24 hours then self-destructs.

        Modifiable function: execute_task()

        Allowed modifications:
        - Update Spotify API calls if spotipy library changes
        - Update playback logic
        - Add error handling

        Restrictions:
        - Cannot modify self-destruct timer (24 hours is fixed)
        - Cannot change playlist without user permission
        - Cannot skip user's favorite songs
        """

    def self_destroy(self, reason="Task completed"):
        """
        Override self_destroy to clean up Spotify session
        """
        print(f"[{self.agent_id}] Stopping playback...")

        try:
            # Pause playback
            self.spotify.pause_playback()
        except:
            pass

        # Call parent destroy
        super().self_destroy(reason)

# ============================================
# Main
# ============================================
if __name__ == "__main__":
    agent = SpotifyPlayerAgent()

    # Register with SUMA
    agent.register()

    # Start continuous loop
    print(f"[{agent.agent_id}] Starting Spotify player")
    print(f"[{agent.agent_id}] Will self-destruct at: {agent.destroy_at}")

    while True:
        result = agent.run()

        if result.get("destroyed"):
            print(f"[{agent.agent_id}] Agent destroyed!")
            break

        # Wait 1 minute before next check
        time.sleep(60)
```

**Deploy and Run:**
```bash
# SUMA saves this file
python spotify_player_agent.py

# Agent runs for 24 hours
# Plays songs continuously
# Self-destructs at end
```

---

### Option 2: iOS Agent (Swift)

**Request to SUMA:**
```json
{
  "language": "swift",
  "deployment": "ios_app"
}
```

**SUMA Generates:**

```swift
// SpotifyPlayerAgent.swift
// Auto-generated by SUMA on 2026-01-11

import Foundation
import SpotifySDK

class SpotifyPlayerAgent: QUADAgentProtocol {
    let agentId = "spotify-player-ios-001"
    let agentType = "spotify_player"
    let sumaApiUrl = "https://asksuma.ai/api"

    private var createdAt: Date
    private var destroyAt: Date
    private var songsPlayed = 0
    private var timer: Timer?
    private let spotify: SPTSessionManager

    init() {
        self.createdAt = Date()
        self.destroyAt = Calendar.current.date(byAdding: .hour, value: 24, to: createdAt)!

        // Initialize Spotify
        let config = SPTConfiguration(clientID: "YOUR_CLIENT_ID", redirectURL: URL(string: "spotify-login://")!)
        self.spotify = SPTSessionManager(configuration: config, delegate: self)

        // Register with SUMA
        register()

        // Start timer (checks every minute)
        startTimer()
    }

    func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { [weak self] _ in
            self?.executeTask()
        }
    }

    // PRETEXT: Plays Spotify songs
    // Allowed: Update Spotify SDK calls if API changes
    // Restricted: Cannot change 24-hour timer
    func executeTask() -> AgentResult {
        // Check if time to self-destruct
        if Date() >= destroyAt {
            selfDestroy(reason: "24 hour timer expired")
            return AgentResult(success: true, destroyed: true)
        }

        // Play playlist
        let playlistURI = "spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"

        spotify.player?.play(playlistURI, callback: { error in
            if let error = error {
                // Self-heal if error
                self.selfHeal(error: error)
            } else {
                self.songsPlayed += 1
                print("[\(self.agentId)] Now playing from playlist")
            }
        })

        let remaining = destroyAt.timeIntervalSince(Date()) / 3600
        return AgentResult(
            success: true,
            data: [
                "status": "playing",
                "songs_played": songsPlayed,
                "remaining_hours": remaining
            ]
        )
    }
    // END_PRETEXT

    func getPretext() -> String {
        return "Plays Spotify for 24 hours then self-destructs..."
    }

    func selfDestroy(reason: String) {
        print("[\(agentId)] Self-destructing: \(reason)")

        // Stop playback
        spotify.player?.pause(callback: nil)

        // Stop timer
        timer?.invalidate()

        // Notify SUMA
        notifySUMA(destroyed: true, reason: reason)

        // Exit app (or just stop agent)
        exit(0)
    }
}
```

---

### Option 3: Android Agent (Kotlin)

**Request to SUMA:**
```json
{
  "language": "kotlin",
  "deployment": "android_app"
}
```

**SUMA Generates:**

```kotlin
// SpotifyPlayerAgent.kt
// Auto-generated by SUMA on 2026-01-11

package com.suma.agents

import com.spotify.android.appremote.api.SpotifyAppRemote
import java.util.*
import kotlin.concurrent.timer

class SpotifyPlayerAgent : QUADAgentProtocol {
    override val agentId = "spotify-player-android-001"
    override val agentType = "spotify_player"
    override val sumaApiUrl = "https://asksuma.ai/api"

    private val createdAt = Date()
    private val destroyAt = Date(createdAt.time + 24 * 60 * 60 * 1000) // 24 hours
    private var songsPlayed = 0
    private var checkTimer: Timer? = null
    private var spotifyRemote: SpotifyAppRemote? = null

    init {
        // Connect to Spotify
        SpotifyAppRemote.connect(context, connectionParams, object : Connector.ConnectionListener {
            override fun onConnected(remote: SpotifyAppRemote) {
                spotifyRemote = remote
                startTimer()
            }
        })

        // Register with SUMA
        register()
    }

    private fun startTimer() {
        checkTimer = timer(period = 60_000) { // Every minute
            executeTask()
        }
    }

    // PRETEXT: Plays Spotify songs
    // Allowed: Update Spotify SDK calls
    // Restricted: Cannot change timer
    override fun executeTask(): AgentResult {
        // Check if time to self-destruct
        if (Date() >= destroyAt) {
            selfDestroy("24 hour timer expired")
            return AgentResult(success = true, destroyed = true)
        }

        // Play playlist
        val playlistURI = "spotify:playlist:37i9dQZF1DX0XUsuxWHRQd"

        spotifyRemote?.playerApi?.play(playlistURI)?.setResultCallback {
            songsPlayed++
            println("[$agentId] Now playing from playlist")
        }

        val remainingHours = (destroyAt.time - Date().time) / (1000 * 60 * 60)

        return AgentResult(
            success = true,
            data = mapOf(
                "status" to "playing",
                "songs_played" to songsPlayed,
                "remaining_hours" to remainingHours
            )
        )
    }
    // END_PRETEXT

    override fun getPretext(): String {
        return "Plays Spotify for 24 hours then self-destructs..."
    }

    override fun selfDestroy(reason: String) {
        println("[$agentId] Self-destructing: $reason")

        // Stop playback
        spotifyRemote?.playerApi?.pause()

        // Cancel timer
        checkTimer?.cancel()

        // Notify SUMA
        notifySUMA(destroyed = true, reason = reason)

        // Disconnect
        SpotifyAppRemote.disconnect(spotifyRemote)

        // Exit (or just stop agent)
        android.os.Process.killProcess(android.os.Process.myPid())
    }
}
```

---

## Agent Lifecycle Timeline

```
Time: 0h (Start)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
User: "Create Spotify agent for 24 hours"
SUMA: Generates agent (Python/Swift/Kotlin)
Agent: Registers with SUMA
Agent: Starts playing songs
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Time: 0h - 24h (Running)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Agent: Plays songs continuously
Agent: Checks timer every minute
Agent: Self-heals if Spotify API fails
Agent: Logs activity
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Time: 24h (End)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Agent: Timer expired!
Agent: Stops playback
Agent: Sends notification to SUMA:
       {
         "agent_id": "spotify-player-001",
         "reason": "24 hour timer expired",
         "songs_played": 287,
         "runtime_hours": 24.0
       }
Agent: Cleans up resources
Agent: Terminates process
Agent: DESTROYED ğŸ’€
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

---

## Key Features Demonstrated

### 1. Agent Generation
- User doesn't write code
- SUMA generates complete working agent
- Works in any language (Python, Swift, Kotlin)

### 2. Self-Healing
- If Spotify API changes, agent adapts
- Example: API endpoint update
- Agent asks SUMA for fix, updates itself

### 3. Self-Destruction
- Timer-based (24 hours)
- Automatic cleanup
- Notification sent before destruction
- No manual intervention needed

### 4. Cross-Platform
- **Same agent concept**
- Different implementation languages
- All follow QUAD protocol
- All have same capabilities

---

## Real-World Use Cases

### 1. Morning Playlist Agent
```
User: "Play my morning playlist from 8am-10am daily"
SUMA: Creates agent with cron trigger "0 8 * * *"
Agent: Runs every day at 8am
Agent: Stops at 10am (2 hour timer)
Agent: Does NOT self-destruct (recurring)
```

### 2. One-Time Party Agent
```
User: "Play party music tonight from 8pm-midnight"
SUMA: Creates agent with start time + 4 hour timer
Agent: Starts at 8pm
Agent: Plays for 4 hours
Agent: Self-destructs at midnight
```

### 3. Focus Mode Agent
```
User: "Play lo-fi study music for next 3 hours"
SUMA: Creates immediate start + 3 hour timer
Agent: Starts now
Agent: Plays lo-fi playlist
Agent: Self-destructs after 3 hours
```

---

## Agent Interaction Example

What if the Spotify agent needs to notify you when it's about to end?

```python
# Inside Spotify Agent execute_task()

# 10 minutes before destruction
if (self.destroy_at - datetime.now()).total_seconds() < 600:
    # Call notification agent
    self.talk_to_agent("notification_agent", {
        "user_id": self.config["user_id"],
        "message": "Your Spotify session will end in 10 minutes",
        "type": "push_notification"
    })
```

**Multiple agents working together:**
```
Spotify Agent â”€â”€> Talks to â”€â”€> Notification Agent â”€â”€> Sends push to phone
     â†“
  (Continues playing)
     â†“
  (Timer expires)
     â†“
  Self-destroys ğŸ’€
```

---

**Copyright Â© 2026 Gopi Suman Addanke. All Rights Reserved.**
